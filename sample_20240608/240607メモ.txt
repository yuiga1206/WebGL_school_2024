


==========================================================================
==========================================================================
==========================================================================






=====================================
24/06/08 第3回目
=====================================

---【前半：座学】---

半径１の円を基準に考える。


角度に対して、どんだけタテに動くか、横に動くか、がサインとコサイン
　┗　


指数表記は桁が増えていくイメージ。
Math.cos(Math.PI / 2) は、
e-17が付くので、ほぼ0。

360度は2PI
ラジアン = 角度 * Math.PI / 180;


単なる数値　＝　スカラー

単位ベクトル　＝　長さが1

ベクトルv = [x, y]
ベクトルvの大きさ　＝　Math.sqrt(x * x + y * y)
ピタゴラスの定理（三平方の定理）の解をルートする
スクエアルート

threejsにはベクトルを単位化するビルトインがある。

単位化はものすごく出てくる…！






---【後半：実習】---

---【017】---


---【018】---

時間の経過をラジアンとみなす　→　ラジアンの代替として使う。
「6.28秒（2π）で一周する」


「時間の経過でなくても、何かしら増加する数値があれば同じ表現はできるということでしょうか？」
　┗　出来る！


サインやコサインの結果の範囲は -1.0 〜 1.0 なので......
必要に応じてスカラー倍してから使う

「このサンプルの場合、月と地球の距離が３で、円半径を３とするので、console.log(cos * ThreeApp.MOON_DISTANCE);の返す値は、3,2,1,0,-1,-2,-3,-2,-1,-0.5,0,1,2,3,ですね？」
　┗　そういうことです！3倍のスケールで起こる。




---【019】---

canvasにイベントを設定して、そこからoffsetXとかが直感的で良いかもしれない。

今は何の世界の話なのか？を気をつける。

「スクリーン空間上のピクセル単位」を3D空間に持って行くには変換が必要になってくる。

画面の中心を原点としたい。


「すみません、ごちゃごちゃして分からなくなってきそうなのですが、スクリーン空間=ビューポートですよね？」
　┗　間違いではない。人によってイメージが違うが、わかりやすいならそう捉えちゃって良い。


const scaleX = pointerX / window.innerWidth * 2.0 - 1.0;
↑難しい計算ではない。
拒否反応を起こさず、じっくり見てほしい。
落ち着いて考える！絶対できる！

pointerX / window.innerWidth　：全体の幅で割って、0.0~1.0の範囲の結果を得られる。
その結果を2倍して　：0.0~2.0の範囲
さらに1を引くと　：-1.0~1.0の範囲になる。
つまり、原点が0,0の位置になる。




---【020】---

ベクトルの単位化

Vector3 クラスは、たくさんのメソッドがある。
大抵のことはメソッドで出来る。困ったらドキュメントを見に行く！




---【021】---

P86：座標とベクトルは違う。
座標(x, y)とベクトル(x, y)は意味が異なる。

原点は(0,0)なので、始点(0,0)と同じ。

お互いの相対的な位置からベクトルを求める。。

一定の速度で進めたい　＝　向きだけに注目する　＝　単位化する

すごく離れている　→　近づいてきた　→　減速しよう
↑という場合は、距離（ベクトルの大きさ）にも注意すれば出来る。

毎フレーム処理をしたいので、renderに書く。


「サンプル021で質問です。月は地球の周りから一定の距離を保つので、ベクトルの正規化が必要なのはわかりました。衛星は正規化が必要な点が理解できていません。正規化しなくても、衛星が月を追いかけることができそうな...？script.jsの290行目「subVector.normalize();」をコメントアウトしても動きが変わらないように見えます。この場合、subVectorに数値を掛けたりする場合を考慮して、正規化しているという理解でしょうか？」
　┗　わざわざ単位化しなくても、自分の狙っている動きなら構わない。
ただ、単位化前のベクトルの長さがどうなっているかわからないのが、気持ち悪い。
それだったら、わかりやすい長さ＝単位化にすれば、表示された結果に納得がある。
subVector が1であることを保証されていたいので、単位化している。






---【022】---

P101:赤いベクトルが大きければ大きいほど、急に曲がる。
小さければ小さいほど、少しだけ曲がる。






---【023】---

オマケと思って良い。。
難しい。今理解しなくて良い。
わからなくても凹まない！！

内積・外積はよく使う。

dot：内積
cross：外積

「姿勢」　→　「回転」を表している。


オイラー角
Eulerクラス


クォータニオン
計算量がかなり節約できたり
ありとあらゆる全ての姿勢を表現できる。
回転を行う上でのメリットがたくさんある。
「どの軸を使って、どのくらい回すか」さえわかれば、全ての姿勢を表現できる。

オイラー角の方がいい場合ももちろんある。

ジンバルロック現象　＝　計算が破綻している状況

「最後の乗算は、座標みたいに加算ではなく、乗算なのはなぜでしょう…？変な質問したらすみません…！」
　┗　クォータニオンは乗算しかないため。加減算はない。
回転の逆転とかも組み込みメソッドで出来る。
四元数とかで調べると、計算方法が出てくるので、なんとなくわかるかも。。


「3DCGでクオータニオンを扱うにあたって、虚数の理解は必要ですか？」
　┗　3DCGのクオータニオンの範疇では必要ない。





---【まとめ】---

「自分が今やりたいことはこういうことだよな…。
このオブジェクトがこういう単位ベクトルを持ってて…」
みたいに、図解するのがオススメ！！



課題：
地球上を飛ぶ旅客機(を模した Box や Plane 等で可)の動きを実現し てみましょう。課題の実装ポイントは「旅客機のような見た目ではな く」、あくまでも「旅客機のような動き」です。
余裕があれば地球上に建築されたビルや、山脈などの自然物なんかも追 加してみてもいいかもしれません。
繰り返しますが、あくまでも 動きを再現する というのが課題の意図で す。グループ機能や、サイン、コサインなど、何を使うのも自由です。 これまでに登場した概念を駆使して実現してみましょう。
↓
↓
座標として、地球の周りを動く。を目指す。
飛行機は作らない。姿勢とかでややこしくなる…！

出せない自分を責めない！
1年後2年後でも良い！！


------------------
【講義後の質問】
------------------

「関係ないのですが、、！最近のcanvasの中にDOMが置ける話題についてお話しを聞きたいです…！」
　┗　


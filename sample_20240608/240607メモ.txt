
=====================================
24/05/11 第一回目
=====================================

---【前半：座学】---

完全に理解したから作る、ではなく、理解半分くらいでどんどん作っていく。
作っていくから残り半分を理解できるようになる。
完全主義は良くない。
半分くらいの理解でいいので、とにかくたくさんやってみる！

楽しみながら取り組むことを忘れない！


https://threejs.org/



https://www.toto.com/jp/neorest/pure_luxury/history/
↑これはthree.jsも使っているが、それだけでなくプラスアルファで自分で書いてる。






---【後半：実習】---

---【001】---
@@@ が変更されたところ。

自分なりにコメントを書き足す。

ハードコーディングだと、その値にどういう意味があるかわかりにくい。
わかりやすい名前の変数にした方が、その値を使う意味が理解しやすい。

一回しか使わないかどうかは最初ではわからない。
将来的に何回使うかはわからないので、最初に定数にしておく。
量が多いと、定数用の別ファイル作ったり…。
管理されている場所が一つなのでわかりやすい。


「constではなくstaticで定義するのは、staticで定義するにあたってメリットがあったりするのでしょうか？」
→　constでもOKだが、ThreeAppクラスがあるので、そのクラスに紐づけておきたい。
別ファイルにしたときに、定数も一緒にインポートされるから。
そのアプリケーションに紐づく定数なので、ThreeAppクラスに入れたい。
思想的な問題…。

中規模以上のアプリケーションを作っているなら、最初から外に定数を定義するかも。

ググるんじゃなくて、公式のドキュメントを見に行く！！
それでもわからなければ、ソースコード見に行く！


CGは前のものを一回消して、新たに書き直している。
それで残像が見えなくなる。そのときに何色で消しますか？っていうのがClearColor。
描画されてないのか失敗しているかどうかがわからないので、
真っ白とか真っ黒とかにはしない。なので中途半端なグレーとかにする。


「canvas要素をhtml側で先に作るのと、renderer.domElementとしてjs側から後からhtml側に入れるのではどちらの方が実案件では多いのでしょうか？ケースバイケースでしょうか？」
→　実案件では最初からcanvasをhtmlで書いていることが多い。
フロントとWebGLで担当が分かれていることが多いので、canvas要素をもらうことが多い。
パフォーマンスの違いはない。どちらでもいい。


ジオメトリ・マテリアル・メッシュはthree.js固有の概念ではあるが、用語としてはCGの世界で一般的な概念としてはある。CG一般の用語。
同じような意味で使われるが、WebGLのネイティブな概念としては無い。




---【002】---

レンダーを連続で更新。
今回はカメラが動いている。

jsではthisは流動的になる。
thisと書いても、その中に何が入っているか時と場合による。

OrbitControls と
requestAnimationFrame を導入して、カメラが動くようになった。


「自分のサイトでTHREEを使いたいがサイズ的にキツイ場合、自分でフォークしてutil削りまくってそちらを使う等したほうが良いでしょうか？」
→　容量を削りたいなら、「import * as THREE from '../lib/three.module.js';」のように一括インポートではなく、必要なものだけインポートするようなカリカリのチューニングが必要。
でもthree.js本体を削ることはあまりしないかも…。


「アロー関数で書くことで、this.render.bind(this) を省略できると思いますが、 実務では、アロー関数を使わずに、bind() を使うことが多いでしょうか？」
→　
// ★★ アロー関数で書くことで、this.render.bind(this) を省略できる？
// ★★ requestAnimationFrame(() => {
// ★★   this.render();
// ★★ });
// ★★ 無駄な関数が作られると思ってしまうので、やらない…。書けるは書ける。


「this.render.bind(this)の、bind(this)はthreeAppクラスを参照しているという理解で合っていますか？」
→　constructor の中なので、ここのthisは自分（ThreeApp）。


「アロー関数の部分について聞き逃したかもしれませんが教えてください。 requestAnimationFrameの中でアローするということは、1フレームごとにアロー関数が生成される＝メモリが消費される。だから、アロー関数での表現はしない。 という理解でよいですか？（つまり002では1回バインドすれば十分で、都度生成されるのは好まない）」
→　そうです！一回bindすれば十分なものを毎フレーム作るのが気持ち悪いので。


「同じような質問ですみません。 requestAnimationFrameの中じゃなくて、 render =() => {..}でthisの固定ってできるよに思えるのですが、 そう書いた場合、 1フレームごとにアロー関数が生成されないように思えるのですがこれは謝ってますか？」
→　正しいです。が、コードがわかりにくくなるし、コンストラクタの中でrenderを定義するという、ちょっとおかしな感じなるので、やらないというだけ。





---【003】---

「ジオメトリの大きさとかaxesHelperの長さの数字って単位は何になりますか？」
→　単位はない…。
自分で 1.0 = 1mと決める！
自分で作る3次元空間において、相対的。
大きい空間にでは1.0 = 1m、
小さい世界なら、1.0 = 1cm、
にしよう…など。
逆にいうと、モデラーに「メートル法でお願いします」とかでやってもらわないといけない。
みんなでコンセンサス取る。
「なるほど…！理解しました！なんの案件なのか（水族館とか）、提供される3Dモデルとかで最初の設定を決める感じですね…！」





---【004】---

Object3D クラスは非常に重要！
このクラスを継承しているクラスがたくさんある！
シーンにアド出来るオブジェクトはみんなそう。

Object3Dを自在に操れるとなんでもできる！！


「マテリアルにテクスチャを貼って表示がぼけないようにするには、ジオメトリのサイズというより画面に表示されるサイズを気をつければいいのでしょうか？」
→　その通りです。
相対的な距離でしか成り立たないので、表示されるサイズを考慮してテクスチャの解像度を考える必要がある。


「プロパティの値を更新するためのメソッドもあるとおもうのですが、プロパティの値を直接更新するのと、関数を利用する使い分けの基準などはありますか？」
→　なるべくset〇〇を作るかも。
「すみません、JS一般にというよりは、Object3Dクラスに、rotateYというメソッドがあったので、this.box.rotation.yに値を代入する違いがあるのかな？という趣旨の質問でした、、！」
→　どちらでもいいかも…。


「サンプルの this.controls.update(); を消してみてもマウス操作できてしまったのですが、このupdate処理は this.renderer.render(this.scene, this.camera); でまかなえてしまっているという理解であってますか？」
→　昔は「this.controls.update();」を呼ばないとダメな仕様だった。
「書かなくても大丈夫」というのが正解。





---【005】---

光源についての話。
004までのメッシュベーシックマテリアルはライトの影響を受けない。
MeshLambertMaterial はライトの影響を受ける。
MeshLambertMaterial は光があたった瞬間だけなので、グラデーションがつかない。

ヘルパーが伸びてる方向がプラス。右手座標系。Z軸が手前。

「this.directionalLight.position.copy(...);のようにcopyを使用しているのは事前に定数化しているからでしょうか？直接座標を指定する場合は、copyは不要でpositionに直接値を指定できるという認識であっておりますか？」
→　あってます。
でもそうすると、xyzで3行になるので。


「平行光源が1.0, 1.0, 1.0にある場合、005ではBoxに向かって（原点方向）光が向いていますよね。ではBoxの逆にも向かっているのでしょうか？たとえばposition 5.0, 5.0, 5.0に同じBoxを置いた場合、そちらにも光は届きますか？」
→　平行光源には長さという概念が無い。向きだけ。
position 5.0, 5.0, 5.0 としても同じ方向から光があたる。

「おっしゃりたいことはわかりました。位置は関係なく、光の向きなのですね。ありがとうございます。5,5,5のBoxには原点側から光るのではないんですね。」


「説明を聞き逃してたらすみません。 directionalLightのpositionの設定でVector3ってますが、 このやり方とthis.directionalLight.position.set(1.0, 1.0, 1.0); 結果はどちらも同じように見えるのですが違いってあるのでしょうか？」
→　違いはないですね。書き方は無数にある。




---【006】---

1面でグラデーションが出来る。
Phong のマテリアルを使うとグラデーションがつく。
MeshLambertMaterial よりかはほんの少しだけ重い。
困るほどではない。

視線が考慮される。

ambientLight は空間全体をぼんやり明るくする。
空間全体に満ちている光（環境光）がある。

光があたっていないところも、ほんのり明るい。

だいたい MeshPhongMaterial を使っておけば問題ない。


directionalLight
ambientLight
のライト二個と、
MeshPhongMaterial
でだいたい出来る。


「光の当たり具合？は使用しているモニター差もあったりしますか？」
→　ディスプレイでは変わらない。




---【007】---

ジオメトリが変わっても、マテリアルは使い回せる。





---【008】---

リサイズ処理が入っている。

レンダラとカメラに再設定する。
レンダラに設定しないと、canvasの大きさが変わらない。
カメラに設定しなくてもダメ。
両方の設定が必要！





---【009】---

マテリアルだけでなく、ジオメトリも使い回す。






---【まとめ】---

課題：
■ Box Geometry を利用すること
■ ボックスが画面上に100個以上描かれるようにすること
■ まっすぐ並べてもいいし......ランダムでもいい(配置の仕方は自由)
■ 色や大きさなどは自由

頑張ってやる！！


すごくセンスのある人がすごいものを出すと、それに面食らって気後れして出さなくなる…。
それは違う！
自分なりにやってみるということが大事！！


「課題の提出はcodepenとかを使ってDiscordに提出でよろしいでしょうか？」
→　これでOK！
サーバーにアップでも、Githubのリンクでも、ソースコードでもOK！


==============
3D プログラミングに限らず、あらゆる 学習は 自身で手を動かしながら、失敗や成功を繰り返していく なかで 身についていきます。

作業時間を捻出するのは大変だと思うのですが、簡単なものでも全然構 いません。ちょっとだけがんばって、自分なりに実装を作ってみてくだ さい。実装していくなかでいろいろ疑問も出てくると思いますが、 Discord 等でいつでも質問してもらって大丈夫です!
==============






==========================================================================
==========================================================================
==========================================================================






=====================================
24/05/25 第2回目
=====================================

---【前半：座学】---

今までは PerspectiveCamera 。

OrthographicCamera を使うと…
非現実的な感じになる。
シムシティとか、ゲームみたいなもの。

立体感が無い方が良いもの。2Dのもの。
建築物とか。

3Dと2Dを行き来するようなものは、パースがかかってないからこそ出来る。
平行投影ならではのもの。




---【後半：実習】---

---【010】---

手前も奥も同じ大きさになる。


3Dの計算の過程で、正立方体になる。
その際、PerspectiveCameraだと前の方が広げられるので、
前の方の物体が大きくなる。

OrthographicCameraは最初から立方体なので、
大きくならない。

「PerspectiveよりOrthographicの方が処理が少ない分負荷が減ったりするものなのでしょうか？」
　┗　減りません！処理フロー自体はどちらも同じ、計算量も同じ。
　　　計算に使う元のデータが違うだけ。

基本は PerspectiveCamera を使うが、
OrthographicCamera じゃないと出せない質感がある。




---【回転の概念】---

3Dやり始めて、最初にはまるポイント…。

3Dでも2Dでも、「回転が先に起こるか平行移動が先に起こるか」を常に考えるように意識する！結果が変わってくる。
しかし、【three.js の世界では「常に」回転が先に起こる】！！

回転は「原点を中心に回転する」ということがあり、世界全体が回転する。

ひとつずつ、3D空間の中心におき、そこで回転させ、移動される。

three.js を使わなければ、回転を後にすることもできるが、それでも3DCG一般的にも回転は先のことが多い。

数学的には線形代数とかのジャンル…

今は「そういうものなんだ」と一旦飲み込んでおく。
【three.js の世界では「常に」回転が先に起こる】


これは暗記！
【回転処理の勘所まとめ】
■ 回転と移動は、どちらが先かによって意味が変わってくる
■ three.js では 回転が常に先 に起こる
■ 回転を加えると世界全体が一気に回転してしまう
■ three.js では Object3D のインスタンスごとに細切れに回転を処理し ている


「初歩的な質問で失礼します。原点って移動できないのでしょうか？p5.jsのtranslate関数みたいなものってないかなと思い質問させていただいた次第です。」
　┗　原点を移動させても、オブジェクトが逆に移動しているのと同じ。なら素直にオブジェクトを動かす方がわかりやすい。
座標に関しては、原点は動かないと考えたほうがシンプル。


「原点と中心という言葉がわからなくなってしまったのですが、オブジェクトを回転するときは、対象のオブジェクトの中心が、回転させるときの原点になる。（3D空間の原点ではなくて）ということであっていますか？」
　┗　あっている。
ローカル空間で、それぞれプラスマイナス方向に同じだけモノがある。ここでいう原点は、ローカルの原点のこと。
対象のオブジェクトの中心というのは、ローカル空間の原点になる。


「回転させたい場合にはまずどこがそのオブジェクトの原点かを考えるのが良いということですか？」
　┗　そう。「原点どこで作ってますか？」と聞いたほうが良いが、先に「ここを原点にしてください」とコンセンサス取ったほうが良い。


「繰り返しでしたらすみませんが、「回転してから移動」のイメージの時の、回転の中心はローカルの原点で相違ないでしょうか？（世界(=canvas)の中心ではなく、ローカルの原点）」
「cssの感覚でいくと、移動させてからでもローカル空間の原点で回転するので混乱しましたが、理解できました。」


「ジオメトリはワールド空間に置かれるもので、 rotation.y += 0.05 というコードが実行されるのは、そのジオメトリのローカル空間のY軸である という理解でよいですか？」
　┗　ジオメトリは設計図なので、実態であるメッシュを動かしている。
メッシュのrotationプロパティに対して、rotation.y += 0.05 としている。


ジオメトリ：設計図、メッシュ：Box等のオブジェクト → new THREE.BoxGeometory等されてはじめてワールド空間に存在する





---【時計の秒針をどうやって実現するか】---
↓
↓
---【011】---

パワポのグループと同じ。

ここは大事！！
↓
回転の原則
■ 3D プログラミングにおける回転とは、世界全体を回転させること
■ 回転は常に世界の中心(原点)で行われる
■ 移動してから回転するのと、回転してから移動するのとでは、意味が まったく違ってくる
■ 3D では一般に、回転を先に行うことが多い
■ three.js でも、やはり回転が先に処理される
■ three.js で移動を先に行いたい場合、グループ機能を活用する






---【012】---

scene オブジェクトが fog プロパティを最初から持っている。

カメラからどれだけ離れているか計算して、離れれば離れるほどオブジェクトを色で塗ってるだけ。
背景色を変えると、どうなっているかわかりやすい。
現実のフォグとは違う。




---【013】---

テクスチャは画像じゃなくてもいい。動画も使える。

ロードが完了してから実行される。完了前に実行されると失敗する。

テクスチャに画像を割り当てて、そのテクスチャをメッシュに貼り付ける。

マテリアルの色と、テクスチャから取り出した色が掛け算されている（乗算）。
なので、マテリアルは白にしておかないと、テクスチャそのものの色が表示されない。


「TextureLoader で読み込む画像の縦横比が 1:1 ではない場合やピクセル数が 2**n ではない場合に気を付けるべきことはありますか？」
　┗　WebGL1.0だと2の累乗（2,4,8,16,32…）じゃないとダメだった。
WebGL2.0だと表示されないことは少ないが、絶対ではないので、怖い場合は2の累乗にしても良い。基本的にはしなくても大丈夫になっている。
現在は基本気にしなくても良い。先生は累乗にしてしまう…怖いから。
1:1の縛りはない。1辺が2の累乗になっていれば、アス比が変わってても大丈夫。






---【014】---

透明度の難点について理解しておくことは非常に重要！！
3DCG業界は透明、半透明は鬼門…！

深度テスト：CGの基本的な原理。
ピクセル一つ一つに対して深度テストが行われている。

半透明なオブジェクト
先に前にあるものに対して、奥にあるものが後から来る。
深度テストで切り捨てられる。

先に後ろにおいといて、後から前に置く。
描画される順番が奥からだったら問題ない。
three.js は自動で描画の順番を変更し、ソートして奥にあるものから描画してくれている。

メッシュ同士が密接になっていると、カメラの位置が変わってしまうことがあり、描画の順番がおかしくなり前のオブジェクトが透けないことがある。
見えてほしいものが、深度テストで切り捨てられるときがある。

半透明によって、深度テストが仇になっている。

半透明は危ない！！
半透明をやると、必ず出てくる問題…！
クライアントに突っ込まれたどうする…？
↑
よくあるのは見え方を工夫する。
シェーダーで工夫する。
など、見え方の工夫でなんとかするしかない。


「手前のオレンジのオブジェクトが自動で後ろに移動していき、後ろの青のオブジェクトより完全に後ろになった時は、青のオブジェクト全体が見えるようにThree.jsは自動で計算するんですか？」
　┗　そう。


「半透明のものって窓とか水とかかなと思うんですが、実際にどういう工夫をされるんでしょうか？窓だったら光が反射して、あんまり半透明な感じを見せないとかですかね…？」
　┗　窓だったら、外の背景とかなので、外のものから描画されるように気をつける。
窓が重なっている場合とかは気をつける。


CG用語：バックフェイスカリング

バックフェイスカリングはちゃんと設定しないとダメ。
勝手に「こっち側だけを描画する」とthree.jsに判定されると、困るときがあるので、マテリアルごとに設定する。
FrontSide
BackSide
DoubleSide
の三択。





---【015】---

CG用語：ポストプロセス　＝　事後処理

とても重要！
品質の向上にとても大きく寄与する。

「絵を作る→加工する→画面に出す」を高速で毎フレームごとにやる

three.jsの用語：エフェクトコンポーザー

グリッチエフェクトを掛けるパス…

three.js本体には入っていない。
examples/jsm/postprocessing に入っている。
有志が開発したオプション機能。

有志が作った便利機能だから、グリッチパスはドキュメントが無い。
ソースコードを見るしかない。






---【016】---

「mesh自体にポストプロセッシングを加えることは可能ですか？」
　┗　ポストプロセスは基本的には画面全体に何かをするもの。
「何も無いレンダーパスに、エフェクトかかったパスを追加」などのややこしい手法を考えれば出来るかも。。
ポストプロセスは、平面の絵になったものに何かする。
なので一つしかモノがないシーンに、別のシーンを合成するとか。。


「画像がどのように貼り付けられるか、はGeometryの点に依存するのだろうか」
　┗　イエス。
座標の値を取得して、自分で上書きすると、張り付く場所を変えれる。
テクスチャ座標、UV






---【まとめ】---

「行列」のページを読む！

ドキュメント読んでもわからなかったり、記述がなかったりがあったら、ソースコードを読みに行くクセをつける。



課題：
■ three.js の Group を駆使して「首振り機能つきの扇風機」を
実現してみましょう。

簡単そうに見えて、実は複数の回転を組み合わせ る必要がある題材なので、グループ機能や回転を扱う練習としてなかな かおもしろいと思います。

形状は適当でも構わないですし複雑じゃなくてよいので、とにかく「回転す る羽」と「首振り」という2つの現象を再現してみましょう

ネタ案：
■ タケコプターをつけたのび太
■ 


==============
覚えることが大量に出てきた第二回講義ですが、今回はこのあたりにし ておきましょう。
一度に全部を漏れなく把握することは誰にとっても難しいことです。講 義の配信動画は何度でも見返すことができますので、焦らずひとつず つ、自分のペースで身につけていくことが大事です。
==============




------------------
【講義後の質問】
------------------

「最初のカメラの話で質問です！インターフェースを映すのはOrthographicカメラ、それ以外の要素を映すのはPerspectiveカメラのように、2種類のカメラで映す対象を変えて、それを1つの画面にレンダリングするということができるという認識で良いでしょうか？」
　┗　可能です！

this.renderer.render(this.scene, this.camera);
this.renderer.render(this.orthoScene, this.orthoCameracamera);
という書き方で出来るかも。
それぞれのシーンで描かれたものが、それぞれのカメラで描かれる。
この場合、autoClearをfalseにしないとダメかも…？


深度テストでインタフェースが隠れないように気をつけないといけない。
場合によっては深度テストを切って、後から描画したり。

けっこうやることはある。


------------------

「Postprocess を動的に制御することは可能でしょうか？例えばスペースキーを押した時のみパスの順番が変わったり一部パスを無効化するなどです。」
　┗　試したこと無いけど、出来そう…。
エフェクトコンポーザーを２つ用意しておいて、キーダウンで切り替えるとか。
　┗　「パス自体にenabledがあるのでそれでいけたりするかもしれません」
　┗　「ちょうどおなじところをみているのですが、パスのrenderToScreenは自動設定されそうで、外部から指定できなさそう？」
　┗　「ありがとうございます！examples側はドキュメント少なさそうですし確認しながら使ったほうがよさそうですね :+1:」


------------------

「本日の回転のお話の時に気になったのですが、課題で作成したドミノでgeometryにtranslate()を使用して回転の軸を変更していました、これは変な使い方でしょうか？ https://hoshino198089.github.io/webgl-school/rotate/」
　┗　わかっててやってるのは変じゃない。
ドミノを倒すために原点をドミノの底辺に持ってくるのは、この場合はそういう発想はめっちゃ良い。




---【前半：座学】---

完全に理解したから作る、ではなく、理解半分くらいでどんどん作っていく。
作っていくから残り半分を理解できるようになる。
完全主義は良くない。
半分くらいの理解でいいので、とにかくたくさんやってみる！

楽しみながら取り組むことを忘れない！


https://threejs.org/



https://www.toto.com/jp/neorest/pure_luxury/history/
↑これはthree.jsも使っているが、それだけでなくプラスアルファで自分で書いてる。






---【後半：実習】---

---【001】---
@@@ が変更されたところ。

自分なりにコメントを書き足す。

ハードコーディングだと、その値にどういう意味があるかわかりにくい。
わかりやすい名前の変数にした方が、その値を使う意味が理解しやすい。

一回しか使わないかどうかは最初ではわからない。
将来的に何回使うかはわからないので、最初に定数にしておく。
量が多いと、定数用の別ファイル作ったり…。
管理されている場所が一つなのでわかりやすい。


「constではなくstaticで定義するのは、staticで定義するにあたってメリットがあったりするのでしょうか？」
→　constでもOKだが、ThreeAppクラスがあるので、そのクラスに紐づけておきたい。
別ファイルにしたときに、定数も一緒にインポートされるから。
そのアプリケーションに紐づく定数なので、ThreeAppクラスに入れたい。
思想的な問題…。

中規模以上のアプリケーションを作っているなら、最初から外に定数を定義するかも。

ググるんじゃなくて、公式のドキュメントを見に行く！！
それでもわからなければ、ソースコード見に行く！


CGは前のものを一回消して、新たに書き直している。
それで残像が見えなくなる。そのときに何色で消しますか？っていうのがClearColor。
描画されてないのか失敗しているかどうかがわからないので、
真っ白とか真っ黒とかにはしない。なので中途半端なグレーとかにする。


「canvas要素をhtml側で先に作るのと、renderer.domElementとしてjs側から後からhtml側に入れるのではどちらの方が実案件では多いのでしょうか？ケースバイケースでしょうか？」
→　実案件では最初からcanvasをhtmlで書いていることが多い。
フロントとWebGLで担当が分かれていることが多いので、canvas要素をもらうことが多い。
パフォーマンスの違いはない。どちらでもいい。


ジオメトリ・マテリアル・メッシュはthree.js固有の概念ではあるが、用語としてはCGの世界で一般的な概念としてはある。CG一般の用語。
同じような意味で使われるが、WebGLのネイティブな概念としては無い。




---【002】---

レンダーを連続で更新。
今回はカメラが動いている。

jsではthisは流動的になる。
thisと書いても、その中に何が入っているか時と場合による。

OrbitControls と
requestAnimationFrame を導入して、カメラが動くようになった。


「自分のサイトでTHREEを使いたいがサイズ的にキツイ場合、自分でフォークしてutil削りまくってそちらを使う等したほうが良いでしょうか？」
→　容量を削りたいなら、「import * as THREE from '../lib/three.module.js';」のように一括インポートではなく、必要なものだけインポートするようなカリカリのチューニングが必要。
でもthree.js本体を削ることはあまりしないかも…。


「アロー関数で書くことで、this.render.bind(this) を省略できると思いますが、 実務では、アロー関数を使わずに、bind() を使うことが多いでしょうか？」
→　
// ★★ アロー関数で書くことで、this.render.bind(this) を省略できる？
// ★★ requestAnimationFrame(() => {
// ★★   this.render();
// ★★ });
// ★★ 無駄な関数が作られると思ってしまうので、やらない…。書けるは書ける。


「this.render.bind(this)の、bind(this)はthreeAppクラスを参照しているという理解で合っていますか？」
→　constructor の中なので、ここのthisは自分（ThreeApp）。


「アロー関数の部分について聞き逃したかもしれませんが教えてください。 requestAnimationFrameの中でアローするということは、1フレームごとにアロー関数が生成される＝メモリが消費される。だから、アロー関数での表現はしない。 という理解でよいですか？（つまり002では1回バインドすれば十分で、都度生成されるのは好まない）」
→　そうです！一回bindすれば十分なものを毎フレーム作るのが気持ち悪いので。


「同じような質問ですみません。 requestAnimationFrameの中じゃなくて、 render =() => {..}でthisの固定ってできるよに思えるのですが、 そう書いた場合、 1フレームごとにアロー関数が生成されないように思えるのですがこれは謝ってますか？」
→　正しいです。が、コードがわかりにくくなるし、コンストラクタの中でrenderを定義するという、ちょっとおかしな感じなるので、やらないというだけ。





---【003】---

「ジオメトリの大きさとかaxesHelperの長さの数字って単位は何になりますか？」
→　単位はない…。
自分で 1.0 = 1mと決める！
自分で作る3次元空間において、相対的。
大きい空間にでは1.0 = 1m、
小さい世界なら、1.0 = 1cm、
にしよう…など。
逆にいうと、モデラーに「メートル法でお願いします」とかでやってもらわないといけない。
みんなでコンセンサス取る。
「なるほど…！理解しました！なんの案件なのか（水族館とか）、提供される3Dモデルとかで最初の設定を決める感じですね…！」





---【004】---

Object3D クラスは非常に重要！
このクラスを継承しているクラスがたくさんある！
シーンにアド出来るオブジェクトはみんなそう。

Object3Dを自在に操れるとなんでもできる！！


「マテリアルにテクスチャを貼って表示がぼけないようにするには、ジオメトリのサイズというより画面に表示されるサイズを気をつければいいのでしょうか？」
→　その通りです。
相対的な距離でしか成り立たないので、表示されるサイズを考慮してテクスチャの解像度を考える必要がある。


「プロパティの値を更新するためのメソッドもあるとおもうのですが、プロパティの値を直接更新するのと、関数を利用する使い分けの基準などはありますか？」
→　なるべくset〇〇を作るかも。
「すみません、JS一般にというよりは、Object3Dクラスに、rotateYというメソッドがあったので、this.box.rotation.yに値を代入する違いがあるのかな？という趣旨の質問でした、、！」
→　どちらでもいいかも…。


「サンプルの this.controls.update(); を消してみてもマウス操作できてしまったのですが、このupdate処理は this.renderer.render(this.scene, this.camera); でまかなえてしまっているという理解であってますか？」
→　昔は「this.controls.update();」を呼ばないとダメな仕様だった。
「書かなくても大丈夫」というのが正解。





---【005】---

光源についての話。
004までのメッシュベーシックマテリアルはライトの影響を受けない。
MeshLambertMaterial はライトの影響を受ける。
MeshLambertMaterial は光があたった瞬間だけなので、グラデーションがつかない。

ヘルパーが伸びてる方向がプラス。右手座標系。Z軸が手前。

「this.directionalLight.position.copy(...);のようにcopyを使用しているのは事前に定数化しているからでしょうか？直接座標を指定する場合は、copyは不要でpositionに直接値を指定できるという認識であっておりますか？」
→　あってます。
でもそうすると、xyzで3行になるので。


「平行光源が1.0, 1.0, 1.0にある場合、005ではBoxに向かって（原点方向）光が向いていますよね。ではBoxの逆にも向かっているのでしょうか？たとえばposition 5.0, 5.0, 5.0に同じBoxを置いた場合、そちらにも光は届きますか？」
→　平行光源には長さという概念が無い。向きだけ。
position 5.0, 5.0, 5.0 としても同じ方向から光があたる。

「おっしゃりたいことはわかりました。位置は関係なく、光の向きなのですね。ありがとうございます。5,5,5のBoxには原点側から光るのではないんですね。」


「説明を聞き逃してたらすみません。 directionalLightのpositionの設定でVector3ってますが、 このやり方とthis.directionalLight.position.set(1.0, 1.0, 1.0); 結果はどちらも同じように見えるのですが違いってあるのでしょうか？」
→　違いはないですね。書き方は無数にある。




---【006】---

1面でグラデーションが出来る。
Phong のマテリアルを使うとグラデーションがつく。
MeshLambertMaterial よりかはほんの少しだけ重い。
困るほどではない。

視線が考慮される。

ambientLight は空間全体をぼんやり明るくする。
空間全体に満ちている光（環境光）がある。

光があたっていないところも、ほんのり明るい。

だいたい MeshPhongMaterial を使っておけば問題ない。


directionalLight
ambientLight
のライト二個と、
MeshPhongMaterial
でだいたい出来る。


「光の当たり具合？は使用しているモニター差もあったりしますか？」
→　ディスプレイでは変わらない。




---【007】---







---【008】---



---【009】---








==========================================================================
==========================================================================
==========================================================================
// ★★ 
// ★★ 

全8回



=====================================
24/07/06 第5回目
=====================================

---【前半：座学】---

案件レベルで受賞するものを作ろうと思うと、ライブラリだけでは通用しない。
ネイティブなWebGLが必要になってくる。

一歩一歩確実にやっていくこと！
わからない、できない自分をくれぐれも責めない！



CPUからGPUにデータを渡す。

ラスタライズ：ベクターをビットマップ（ラスタ画像）にする。


「パイプライン上で各種制御を行うプログラム」こそが シェーダ と呼ばれる概念

CPU と GPU は、いわばフロントエンドとバックエンドのように完全に切り離された世界です。
＝　JavaScript とシェーダは、全然違う世界！


WebGL には3角形までしかない。
4角形以上は無いので、すべて3角形の組み合わせで表現する。
OpenGL だと多角形はある。

頂点属性
vertex attribute


WebGL は GPU 上に存在するレンダリングパイプラインを使い絵を描いており...... 
プログラマブルなパイプラインで必要となるシェーダのプログラムを用意してやる必要があり......
WebGL では頂点しか描画することができないので頂点を定義する必要があり...... 
頂点は、その頂点が持つ座標や色など「任意の数の頂点属性」を組み合わせることで1つの単位として定義される



「頂点属性のまとまりがクラスみたいに見なせそうに思いましたがあまり意味がないですかね。(意味がない or 間違った解釈になってしまうなど)」
　┗　似てると思います。ちょっとクラスとは違うけど、イメージは合っている。





---【後半：実習】---

---【001】---

newsしなくても、直接呼び出せるのが、staticなメソッド。
Math.sin()
みたいなのがstaticなメソッド

new Date().○○
みたいななのが動的なメソッド


「すみません、、、今回は　this.gl = WebGLUtility.createWebGLContext(this.canvas);ですが、ネイティブなAPIを使用するときは this.gl = WebGLRenderingContext.createWebGLContext(this.canvas);になるのでしょうか？」
　┗　ちょっと違う。
const gl = canvas.getContext('webgl');
直接書くなら↑こう書くだけ。


バッファをバインドする…
バインド　=　料理で言うなら「まな板にのせる」。
使うことを宣言する、ようなこと。
WebGL だとバインドがよく出る。
まずバインドして、それから処理を加える。
最後にバインドを解除する。



VBOの動的書き換えは基本的にはしない。
なぜならGPUのコストが高い…。

あとからシェーダでどうにかする方がコストが低い。
（その後のレンダリングパイプラインの過程で動かす）



頂点シェーダは 頂点1つ1つに対して個別に実行される というのがとても重要です。
頂点が100個あれば、頂点シェーダは GPU 内で100回実行されます。


「コンパイルって事前にされたりしないものなのでしょうか。」
　┗　GLSLのコンパイルは事前には出来ない。
昔は実行環境でコンパイルしないといけなかった。各ユーザーのマシンでコンパイルしてた。
今はブラウザ上でコンパイルしている。


プログラムオブジェクトは何個も作れる。


「大規模なものはfetch,compileをするタイミングによってパフォーマンス変わりそうですね」
　┗　シェーダが何十個もあるならそうかも。three.jsとかなら、実際に描画されるまでコンパイルされないかも。


attribute が付いてたらVBOと紐付く修飾子だと思って良い。


「私の環境では、.vertファイルは白文字だけで表示されてるんですが、エディター（VScode）でおすすめのGLSL用のプラグインはありますか？」
　┗　Shader languages support for VS Code


「すいません、少し話が戻るのですが、頂点は3つまでしか渡せないと話があったと思います。四角形を作りたい場合は、三角形が2つ必要なのでthis.positionの配列の中に、さらに3つの頂点情報を追加するのでしょうか？」
　┗　四角形ポリゴンを描写する機能がないので、4つめの頂点を指定しても、3個までしか使ってくれない。
これは3個までしか使えないのではなく、3の倍数＝3個でワンセットで使える。頂点は何個でも渡せる。
つまり四角形を作るなら、6個の頂点の指定がいる。



シェーダはキャッシュされるので、変更されない場合はキャッシュを消して再読み込みする。



「最終的にgl_FragColorはmain関数内では1回しか出力できないですか？ それともgl_FragColorを複数回出力することも可能ですか？」
　┗　レンダリングパイプラインを考えると、一回しか出力できない。
何回書いてもいいが、一番最後だけ採用される。
「なるほど。一番最後のgl_FragColorが適用されるんですね」




---【002】---

「頂点の色は常にrgbaという決まりで、rgbだとエラーが出たりしますか？」
　┗　エラーは出ないが、ve4 → vec3 とかに変更する。
ve4(color, 1.0)
this.colorStride = 3;
とかも。



「フラグメントシェーダーに直接渡すこともできますか？」
　┗　出来ない…！
パイプラインを考えると、フラグメントシェーダの処理の前に、
ラスタライズが挟まってるので、
頂点シェーダ上での頂点の情報はベクターだが、
フラグメントシェーダ上ではビットマップ＝ピクセルになってしまっている。

頂点シェーダ　→　ラスタライズ　→　フラグメントシェーダ
＝
ベクター　→　ラスタライズ　→　ビットマップ

attribute 変数は、頂点シェーダにしか書けない。


「varingの入力と出力で同じものじゃない、ということなんでしょうか」
　┗　今まで頂点だったものが、ピクセルの集合になって出力される。
「なるほど。色だから、という話じゃないですね。」







---【003】---

たとえば、時間の経過などはJSの世界（CPUの世界）で調べて、
GLSLの世界に送る、ということが必要。










---【004】---

今回の課題…！







---【まとめ】---

とにかく落ち込まないこと！
わかることからやっていくこと！


【大事なポイント】
■ シェーダは GPU側にいる
■ シェーダが使うデータは GPU にあらかじめ送っておく必要がある 
■ GPU に送られるデータにはいくつか種類があり...... 
■ VBO(attribute)として送るものと uniform として送るものがある 
■ それらの方法の違いにより GLSL 内部では修飾子が変わる





課題：


------------------
【講義後の質問】
------------------


